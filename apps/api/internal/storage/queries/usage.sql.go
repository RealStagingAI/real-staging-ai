// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: usage.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountImagesCreatedInPeriod = `-- name: CountImagesCreatedInPeriod :one
SELECT COUNT(*)::int
FROM images i
JOIN projects p ON i.project_id = p.id
WHERE p.user_id = $1
  AND i.created_at >= $2
  AND i.created_at < $3
`

type CountImagesCreatedInPeriodParams struct {
	UserID      pgtype.UUID        `json:"user_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

// Count how many images a user created within a specific date range
func (q *Queries) CountImagesCreatedInPeriod(ctx context.Context, arg CountImagesCreatedInPeriodParams) (int32, error) {
	row := q.db.QueryRow(ctx, CountImagesCreatedInPeriod, arg.UserID, arg.CreatedAt, arg.CreatedAt_2)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const GetPlanByCode = `-- name: GetPlanByCode :one
SELECT id, code, price_id, monthly_limit
FROM plans
WHERE code = $1
`

// Get a plan by its code (free, pro, business, etc.)
func (q *Queries) GetPlanByCode(ctx context.Context, code string) (*Plan, error) {
	row := q.db.QueryRow(ctx, GetPlanByCode, code)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.PriceID,
		&i.MonthlyLimit,
	)
	return &i, err
}

const GetPlanByPriceID = `-- name: GetPlanByPriceID :one
SELECT id, code, price_id, monthly_limit
FROM plans
WHERE price_id = $1
`

// Get a plan by its Stripe price ID
func (q *Queries) GetPlanByPriceID(ctx context.Context, priceID string) (*Plan, error) {
	row := q.db.QueryRow(ctx, GetPlanByPriceID, priceID)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.PriceID,
		&i.MonthlyLimit,
	)
	return &i, err
}

const GetUserActivePlan = `-- name: GetUserActivePlan :one
SELECT p.id, p.code, p.price_id, p.monthly_limit
FROM plans p
JOIN subscriptions s ON s.price_id = p.price_id
WHERE s.user_id = $1
  AND s.status IN ('active', 'trialing')
ORDER BY s.created_at DESC
LIMIT 1
`

// Get the user's current active plan based on their subscription
// Returns the plan for active/trialing subscriptions, or NULL if no active subscription
func (q *Queries) GetUserActivePlan(ctx context.Context, userID pgtype.UUID) (*Plan, error) {
	row := q.db.QueryRow(ctx, GetUserActivePlan, userID)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.PriceID,
		&i.MonthlyLimit,
	)
	return &i, err
}

const ListAllPlans = `-- name: ListAllPlans :many
SELECT id, code, price_id, monthly_limit
FROM plans
ORDER BY monthly_limit ASC
`

// List all available plans
func (q *Queries) ListAllPlans(ctx context.Context) ([]*Plan, error) {
	rows, err := q.db.Query(ctx, ListAllPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Plan{}
	for rows.Next() {
		var i Plan
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.PriceID,
			&i.MonthlyLimit,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
