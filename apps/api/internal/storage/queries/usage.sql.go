// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: usage.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountImagesCreatedInPeriod = `-- name: CountImagesCreatedInPeriod :one
SELECT COUNT(*)::int
FROM images i
JOIN projects p ON i.project_id = p.id
WHERE p.user_id = $1
  AND i.created_at >= $2
  AND i.created_at < $3
`

type CountImagesCreatedInPeriodParams struct {
	UserID      pgtype.UUID        `json:"user_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

// Count how many images a user created within a specific date range
// IMPORTANT: This counts ALL images (including soft-deleted) to prevent gaming the system
// Users cannot reduce their usage count by deleting images
func (q *Queries) CountImagesCreatedInPeriod(ctx context.Context, arg CountImagesCreatedInPeriodParams) (int32, error) {
	row := q.db.QueryRow(ctx, CountImagesCreatedInPeriod, arg.UserID, arg.CreatedAt, arg.CreatedAt_2)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const CreatePlan = `-- name: CreatePlan :one
INSERT INTO plans (id, code, price_id, monthly_limit)
VALUES ($1, $2, $3, $4)
RETURNING id, code, price_id, monthly_limit
`

type CreatePlanParams struct {
	ID           pgtype.UUID `json:"id"`
	Code         string      `json:"code"`
	PriceID      string      `json:"price_id"`
	MonthlyLimit int32       `json:"monthly_limit"`
}

// Create a new plan
func (q *Queries) CreatePlan(ctx context.Context, arg CreatePlanParams) (*Plan, error) {
	row := q.db.QueryRow(ctx, CreatePlan,
		arg.ID,
		arg.Code,
		arg.PriceID,
		arg.MonthlyLimit,
	)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.PriceID,
		&i.MonthlyLimit,
	)
	return &i, err
}

const GetPlanByCode = `-- name: GetPlanByCode :one
SELECT id, code, price_id, monthly_limit
FROM plans
WHERE code = $1
`

// Get a plan by its code (free, pro, business, etc.)
func (q *Queries) GetPlanByCode(ctx context.Context, code string) (*Plan, error) {
	row := q.db.QueryRow(ctx, GetPlanByCode, code)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.PriceID,
		&i.MonthlyLimit,
	)
	return &i, err
}

const GetPlanByPriceID = `-- name: GetPlanByPriceID :one
SELECT id, code, price_id, monthly_limit
FROM plans
WHERE price_id = $1
`

// Get a plan by its Stripe price ID
func (q *Queries) GetPlanByPriceID(ctx context.Context, priceID string) (*Plan, error) {
	row := q.db.QueryRow(ctx, GetPlanByPriceID, priceID)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.PriceID,
		&i.MonthlyLimit,
	)
	return &i, err
}

const GetUserActivePlan = `-- name: GetUserActivePlan :one
SELECT p.id, p.code, p.price_id, p.monthly_limit
FROM plans p
JOIN subscriptions s ON s.price_id = p.price_id
WHERE s.user_id = $1
  AND s.status IN ('active', 'trialing')
ORDER BY s.created_at DESC
LIMIT 1
`

// Get the user's current active plan based on their subscription
// Returns the plan for active/trialing subscriptions, or NULL if no active subscription
func (q *Queries) GetUserActivePlan(ctx context.Context, userID pgtype.UUID) (*Plan, error) {
	row := q.db.QueryRow(ctx, GetUserActivePlan, userID)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.PriceID,
		&i.MonthlyLimit,
	)
	return &i, err
}

const ListAllActiveSubscriptions = `-- name: ListAllActiveSubscriptions :many
SELECT id, user_id, stripe_subscription_id, status, price_id, current_period_start, current_period_end, cancel_at, canceled_at, cancel_at_period_end, created_at, updated_at
FROM subscriptions
WHERE status IN ('active', 'trialing')
`

// List all active subscriptions (for validation)
func (q *Queries) ListAllActiveSubscriptions(ctx context.Context) ([]*Subscription, error) {
	rows, err := q.db.Query(ctx, ListAllActiveSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.StripeSubscriptionID,
			&i.Status,
			&i.PriceID,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.CancelAt,
			&i.CanceledAt,
			&i.CancelAtPeriodEnd,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAllPlans = `-- name: ListAllPlans :many
SELECT id, code, price_id, monthly_limit
FROM plans
ORDER BY monthly_limit ASC
`

// List all available plans
func (q *Queries) ListAllPlans(ctx context.Context) ([]*Plan, error) {
	rows, err := q.db.Query(ctx, ListAllPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Plan{}
	for rows.Next() {
		var i Plan
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.PriceID,
			&i.MonthlyLimit,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdatePlan = `-- name: UpdatePlan :one
UPDATE plans 
SET price_id = $2, monthly_limit = $3
WHERE code = $1
RETURNING id, code, price_id, monthly_limit
`

type UpdatePlanParams struct {
	Code         string `json:"code"`
	PriceID      string `json:"price_id"`
	MonthlyLimit int32  `json:"monthly_limit"`
}

// Update an existing plan
func (q *Queries) UpdatePlan(ctx context.Context, arg UpdatePlanParams) (*Plan, error) {
	row := q.db.QueryRow(ctx, UpdatePlan, arg.Code, arg.PriceID, arg.MonthlyLimit)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.PriceID,
		&i.MonthlyLimit,
	)
	return &i, err
}
