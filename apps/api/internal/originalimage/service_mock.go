// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package originalimage

import (
	"context"
	"sync"
	"time"
)

// Ensure, that ServiceMock does implement Service.
// If this is not the case, regenerate this file with moq.
var _ Service = &ServiceMock{}

// ServiceMock is a mock implementation of Service.
//
//	func TestSomethingThatUsesService(t *testing.T) {
//
//		// make and configure a mocked Service
//		mockedService := &ServiceMock{
//			CleanupOrphanedOriginalsFunc: func(ctx context.Context, olderThan time.Duration, limit int) (int, error) {
//				panic("mock out the CleanupOrphanedOriginals method")
//			},
//			DecrementReferenceAndCleanupFunc: func(ctx context.Context, originalImageID string) (bool, error) {
//				panic("mock out the DecrementReferenceAndCleanup method")
//			},
//			GetStatsFunc: func(ctx context.Context) (*OriginalImageStats, error) {
//				panic("mock out the GetStats method")
//			},
//		}
//
//		// use mockedService in code that requires Service
//		// and then make assertions.
//
//	}
type ServiceMock struct {
	// CleanupOrphanedOriginalsFunc mocks the CleanupOrphanedOriginals method.
	CleanupOrphanedOriginalsFunc func(ctx context.Context, olderThan time.Duration, limit int) (int, error)

	// DecrementReferenceAndCleanupFunc mocks the DecrementReferenceAndCleanup method.
	DecrementReferenceAndCleanupFunc func(ctx context.Context, originalImageID string) (bool, error)

	// GetStatsFunc mocks the GetStats method.
	GetStatsFunc func(ctx context.Context) (*OriginalImageStats, error)

	// calls tracks calls to the methods.
	calls struct {
		// CleanupOrphanedOriginals holds details about calls to the CleanupOrphanedOriginals method.
		CleanupOrphanedOriginals []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OlderThan is the olderThan argument value.
			OlderThan time.Duration
			// Limit is the limit argument value.
			Limit int
		}
		// DecrementReferenceAndCleanup holds details about calls to the DecrementReferenceAndCleanup method.
		DecrementReferenceAndCleanup []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OriginalImageID is the originalImageID argument value.
			OriginalImageID string
		}
		// GetStats holds details about calls to the GetStats method.
		GetStats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockCleanupOrphanedOriginals     sync.RWMutex
	lockDecrementReferenceAndCleanup sync.RWMutex
	lockGetStats                     sync.RWMutex
}

// CleanupOrphanedOriginals calls CleanupOrphanedOriginalsFunc.
func (mock *ServiceMock) CleanupOrphanedOriginals(ctx context.Context, olderThan time.Duration, limit int) (int, error) {
	if mock.CleanupOrphanedOriginalsFunc == nil {
		panic("ServiceMock.CleanupOrphanedOriginalsFunc: method is nil but Service.CleanupOrphanedOriginals was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		OlderThan time.Duration
		Limit     int
	}{
		Ctx:       ctx,
		OlderThan: olderThan,
		Limit:     limit,
	}
	mock.lockCleanupOrphanedOriginals.Lock()
	mock.calls.CleanupOrphanedOriginals = append(mock.calls.CleanupOrphanedOriginals, callInfo)
	mock.lockCleanupOrphanedOriginals.Unlock()
	return mock.CleanupOrphanedOriginalsFunc(ctx, olderThan, limit)
}

// CleanupOrphanedOriginalsCalls gets all the calls that were made to CleanupOrphanedOriginals.
// Check the length with:
//
//	len(mockedService.CleanupOrphanedOriginalsCalls())
func (mock *ServiceMock) CleanupOrphanedOriginalsCalls() []struct {
	Ctx       context.Context
	OlderThan time.Duration
	Limit     int
} {
	var calls []struct {
		Ctx       context.Context
		OlderThan time.Duration
		Limit     int
	}
	mock.lockCleanupOrphanedOriginals.RLock()
	calls = mock.calls.CleanupOrphanedOriginals
	mock.lockCleanupOrphanedOriginals.RUnlock()
	return calls
}

// DecrementReferenceAndCleanup calls DecrementReferenceAndCleanupFunc.
func (mock *ServiceMock) DecrementReferenceAndCleanup(ctx context.Context, originalImageID string) (bool, error) {
	if mock.DecrementReferenceAndCleanupFunc == nil {
		panic("ServiceMock.DecrementReferenceAndCleanupFunc: method is nil but Service.DecrementReferenceAndCleanup was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		OriginalImageID string
	}{
		Ctx:             ctx,
		OriginalImageID: originalImageID,
	}
	mock.lockDecrementReferenceAndCleanup.Lock()
	mock.calls.DecrementReferenceAndCleanup = append(mock.calls.DecrementReferenceAndCleanup, callInfo)
	mock.lockDecrementReferenceAndCleanup.Unlock()
	return mock.DecrementReferenceAndCleanupFunc(ctx, originalImageID)
}

// DecrementReferenceAndCleanupCalls gets all the calls that were made to DecrementReferenceAndCleanup.
// Check the length with:
//
//	len(mockedService.DecrementReferenceAndCleanupCalls())
func (mock *ServiceMock) DecrementReferenceAndCleanupCalls() []struct {
	Ctx             context.Context
	OriginalImageID string
} {
	var calls []struct {
		Ctx             context.Context
		OriginalImageID string
	}
	mock.lockDecrementReferenceAndCleanup.RLock()
	calls = mock.calls.DecrementReferenceAndCleanup
	mock.lockDecrementReferenceAndCleanup.RUnlock()
	return calls
}

// GetStats calls GetStatsFunc.
func (mock *ServiceMock) GetStats(ctx context.Context) (*OriginalImageStats, error) {
	if mock.GetStatsFunc == nil {
		panic("ServiceMock.GetStatsFunc: method is nil but Service.GetStats was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetStats.Lock()
	mock.calls.GetStats = append(mock.calls.GetStats, callInfo)
	mock.lockGetStats.Unlock()
	return mock.GetStatsFunc(ctx)
}

// GetStatsCalls gets all the calls that were made to GetStats.
// Check the length with:
//
//	len(mockedService.GetStatsCalls())
func (mock *ServiceMock) GetStatsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetStats.RLock()
	calls = mock.calls.GetStats
	mock.lockGetStats.RUnlock()
	return calls
}
